<h2>My Heroes</h2>
<ul class="heroes">
  <!-- Add `*ngFor` to the `<li>` to iterate through the list of heroes

  The `*ngFor` is Angular's *repeater* directive
  It repeats the host element for each element in a list
  The syntax in this example is as follows:
  * `<li>` is the host element
  * `heroes` holds the mock heroes list from the `HeroesComponent` class, the mock heroes list
  * `hero` holds the current hero object for each iteration through the list

  The event binding listens for the button's click events and calls the component's `onSelect()` method whenever a click occurs
  i.e. The parentheses around `click` tell Angular to listen for the `<li>` element's `click` event, then when a user clicks in the `<li>`, Angular executes the `onSelect(hero)` expression
  This is an example of Angular's event binding syntax
  `(click)` is the target event name, and `onSelect(hero)` is the template statement

  To style the selected hero, Angular class binding makes it easy to add and remove a CSS class conditionally
  Just add `[class.some-css-class]="some-condition"` to the element you want to style
  Here when the current row hero is the same as the `selectedHero`, Angular adds the `selected` CSS class
  When the two heroes are different, Angular removes the class -->
  <li *ngFor="let hero of heroes"
      [class.selected]="hero === selectedHero"
      (click)="onSelect(hero)">
    <span class="badge">{{ hero.id }}</span> {{ hero.name }}
  </li>
</ul>

<!-- Add data binding to the new `hero` property -->
<!--{{ hero }}-->

<!-- When the app starts, the `selectedHero` is `undefined` *by design*
Binding expressions in the template that refer to properties of `selectedHero`, expressions like `{{ selectedHero.name }}`, *must fail* because there is no selected hero

This is the rationale for adding `ngIf`
When `selectedHero` is undefined, the `ngIf` removes the hero detail from the DOM, because there are no `selectedHero` bindings to consider
When the user picks a hero, `selectedHero` has a value and `ngIf` puts the hero detail into the DOM -->
<div *ngIf="selectedHero">
  <!-- Update the binding in the template to announce the hero's name and show both `id` and `name` in a details layout

   The word `uppercase` in the interpolation binding, right after the pipe operator (|), activates the built-in `UppercasePipe`
   Pipes are a good way to format strings, currency amounts, dates, and other display data
   Angular ships with several built-in pipes, and you can create your own -->
  <h2>{{ selectedHero.name | uppercase }} Details</h2>
  <div>
    <span>id: </span> {{ selectedHero.id }}
  </div>
  <div>
    <!-- `[(ngModel)]` is Angular's two-way binding syntax
    Here it binds to the `selectedHero.name` property to the HTML textbox so that data can flow *in both directions*: from the `selectedHero.name` property to the textbox, and from the textbox back to the `selectedHero.name`

    When we added `[(ngModel)]`, our app stopped working
    This is because although `ngModel` is a valid Angular directive, it isn't available by default
    It belongs to the optional `FormsModule` and you must *opt-in* to using it in `@NgModule`'s `imports` array -->
    <label>
      name: <input [(ngModel)]="selectedHero.name" placeholder="name"/>
    </label>
  </div>
</div>
